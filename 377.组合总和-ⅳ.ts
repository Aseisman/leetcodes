/*
 * @lc app=leetcode.cn id=377 lang=typescript
 *
 * [377] 组合总和 Ⅳ
 */

// @lc code=start
// 贪心会超时，得用dp
function combinationSum4(nums: number[], target: number): number {
    // 先举个例子，nums = [1, 2, 3]，target = 35.
    // 假设用1，2，3拼凑出35的总组合个数为y。我们可以考虑三种情况：
    // （1）有效组合的末尾数字为1，这类组合的个数为 x1。我们把所有该类组合的末尾1去掉，那么不难发现，我们找到了一个子问题，x1即为在[1，2，3]中凑出35 - 1 = 34的总组合个数。因为我如果得到了和为34的所有组合，我只要在所有组合的最后面，拼接一个1，就得到了和为35且最后一个数字为1的组合个数了。
    // （2）有效组合的末尾数字为2，这类组合的个数为 x2。我们把所有该类组合的末尾2去掉，那么不难发现，我们找到了一个子问题，x2即为在[1，2，3]中凑出35 - 2 = 33的总组合个数。因为我如果得到了和为33的所有组合，我只要在所有组合的最后面，拼接一个2，就得到了和为35且最后一个数字为2的组合个数了。
    // （3）有效组合的末尾数字为3，这类组合的个数为 x3。我们把所有该类组合的末尾3去掉，那么不难发现，我们找到了一个子问题，x3即为在[1，2，3]中凑出35 - 3 = 32的总组合个数。因为我如果得到了和为32的所有组合，我只要在所有组合的最后面，拼接一个3，就得到了和为35且最后一个数字为3的组合个数了。
    // 这样就简单了，y = x1 + x2 + x3。而x1，x2，x3又可以用同样的办法从子问题得到。状态转移方程get！
    let dp = new Array(target+1).fill(0);
    dp[0] = 1; //dp[i]表示，几个数相加达到i时的数量 最终返回dp[target]
    for (let i = 1; i <= target; i++) {
      for (let num of nums) {
        if (num <= i) {
          dp[i] += dp[i - num] || 0;
        }
      }
    }
    return dp[target];
};
// 进阶：如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？
// 答：如果允许负数出现，则必须限制排列的最大长度，避免出现无限长度的排列，才能计算排列数
// @lc code=end

